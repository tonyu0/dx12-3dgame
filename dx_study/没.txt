
// FBX読み込んで描画しようとしたもの

#include <fbxsdk.h>
void main() {

	//FbxManagerとFbxSceneオブジェクトを作成
	FbxManager* manager = FbxManager::Create();
	FbxIOSettings* ios = FbxIOSettings::Create(manager, IOSROOT);
	manager->SetIOSettings(ios);
	FbxScene* scene = FbxScene::Create(manager, "");

	//データをインポート
	const char* filename = "assets/BOYDANCE.fbx";
	std::cout << "File: " << filename << std::endl;
	FbxImporter* importer = FbxImporter::Create(manager, "");
	importer->Initialize(filename, -1, manager->GetIOSettings());
	importer->Import(scene);
	importer->Destroy();
	//三角ポリゴン化
	FbxGeometryConverter geometryConverter(manager);
	geometryConverter.Triangulate(scene, true);
	DisplayContent(scene);

	manager->Destroy();


}


void DisplayIndex(FbxMesh* mesh) {
	//総ポリゴン数
	int polygonNum = mesh->GetPolygonCount();
	//p個目のポリゴンへの処理
	for (int p = 0; p < polygonNum; ++p)
		//p個目のポリゴンのn個目の頂点への処理
		for (int n = 0; n < 3; ++n) {
			int index = mesh->GetPolygonVertex(p, n);
			std::cout << "index[" << p + n << "] : " << index << std::endl;
		}
}

void DisplayMesh(FbxNode* node) {
	FbxMesh* mesh = (FbxMesh*)node->GetNodeAttribute();
	std::cout << "\n\nMesh Name: " << (char*)node->GetName() << std::endl;
	DisplayIndex(mesh);

	int positionNum = mesh->GetControlPointsCount();	// 頂点数
	FbxVector4* vertices = mesh->GetControlPoints();	// 頂点座標配列
	int indices = mesh->GetPolygonCount();
	// ポリゴンの数だけ連番として保存する
	for (int i = 0; i < mesh->GetPolygonCount(); i++)
	{
		// ただ、FBXは右手系で作られているのでポリゴンの作成が左周りになっています。
		// DirectXは右周りなので、少し順番を変更します。
		// 2 => 1 => 0にしてるのは左手系対策
		//m_Indices[node_name].push_back(i * 3 + 2);
		//m_Indices[node_name].push_back(i * 3 + 1);
		//m_Indices[node_name].push_back(i * 3);
	}
}

// ControlPoints = 頂点バッファ、 PolugonVertexCount = 頂点座標？
void CollectMeshInfo(FbxNode* node) {
	for (int i = 0; i < node->GetNodeAttributeCount(); ++i) {
		FbxNodeAttribute* attribute = node->GetNodeAttributeByIndex(i);

		std::string node_name = node->GetName();
		// add if attibute is mesh
		if (attribute->GetAttributeType() == FbxNodeAttribute::EType::eMesh) {
			// position and normal is in mesh
			FbxMesh* mesh = static_cast<FbxMesh*>(attribute);
			int	index_count = mesh->GetPolygonVertexCount();
			int* indices = mesh->GetPolygonVertices();
			// index bufferのコピー
			for (int i = 0; i < mesh->GetPolygonCount(); ++i) {
				mesh_indices[node_name].push_back(i * 3);
				mesh_indices[node_name].push_back(i * 3 + 1);
				mesh_indices[node_name].push_back(i * 3 + 2);
			}

			// mesh->GetPolygonVertexCount(); // 実際のメッシュ上の頂点の数
			int vertex_count = mesh->GetControlPointsCount();
			FbxVector4* vertices = mesh->GetControlPoints();
			// elementって何？頂点バッファ数より3倍くらい多い。
			//int elementCount = mesh->GetElementNormalCount();
			//auto element = mesh->GetElementNormal();
			//auto mappingMode = element->GetMappingMode();
			//auto referenceMode = element->GetReferenceMode();
			//const auto& indexArray = element->GetIndexArray();
			//const auto& directArray = element->GetDirectArray();
			FbxArray<FbxVector4> normals;
			mesh->GetPolygonVertexNormals(normals);
			std::cout << "ELEMENTS COUNT: " << vertex_count << " " << index_count << " " << normals.Size() << std::endl;
			// index
			for (int i = 0; i < index_count; ++i) {
				int idx = indices[i];
				Vertex vertex;
				vertex.pos.x = (FLOAT)vertices[idx][0];
				vertex.pos.y = (FLOAT)vertices[idx][1];
				vertex.pos.z = (FLOAT)vertices[idx][2];

				// debug用、バウンディングボックス作成
				minX = std::fminf(minX, vertex.pos.x);
				maxX = std::fmaxf(maxX, vertex.pos.x);
				minY = std::fminf(minY, vertex.pos.y);
				maxY = std::fmaxf(maxY, vertex.pos.y);
				minZ = std::fminf(minZ, vertex.pos.z);
				maxZ = std::fmaxf(maxZ, vertex.pos.z);
				mesh_vertices[node_name].emplace_back(vertex);
			}

			// normalは実際の座標ごとにしか取れない？
			// すでにverticesにはindicesで指定する位置に目的の値が入っている。なので普通にループ可能。
			for (int i = 0; i < normals.Size(); ++i) {
				mesh_vertices[node_name][i].normal.x = normals[i][0];
				mesh_vertices[node_name][i].normal.y = normals[i][1];
				mesh_vertices[node_name][i].normal.z = normals[i][2];
			}
			break;
		}
	}
	std::cout << node->GetName() << std::endl;
	std::cout << "READ ATTRCNT: " << node->GetNodeAttributeCount() << std::endl;
	for (int i = 0; i < node->GetChildCount(); i++)
		CollectMeshInfo(node->GetChild(i));
}

void GetVertexInfo(FbxMesh* mesh) {
	const FbxVector4* mesh_vertices = mesh->GetControlPoints();
	int* mesh_indices = mesh->GetPolygonVertices();

	for (int i = 0; i < mesh->GetPolygonVertexCount(); ++i) {
		int index = mesh_indices[i];
	}

}